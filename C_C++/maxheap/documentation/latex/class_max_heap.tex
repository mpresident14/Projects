\hypertarget{class_max_heap}{}\section{Max\+Heap$<$ T $>$ Class Template Reference}
\label{class_max_heap}\index{Max\+Heap$<$ T $>$@{Max\+Heap$<$ T $>$}}


Implementation of a max heap binary tree.  




{\ttfamily \#include $<$maxheap.\+hpp$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_max_heap_a699765b3f302e72791fe0de91c36aa39}{Max\+Heap} ()
\begin{DoxyCompactList}\small\item\em Default Constructor. \end{DoxyCompactList}\item 
\hyperlink{class_max_heap_a059ca3f1547c9695df3b2ed6b78ba762}{Max\+Heap} (T array\mbox{[}$\,$\mbox{]}, size\+\_\+t length)
\begin{DoxyCompactList}\small\item\em Parameterized Constructor. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_max_heap_a24cddc2c00ab5145d4073a8609583047}\label{class_max_heap_a24cddc2c00ab5145d4073a8609583047}} 
{\bfseries Max\+Heap} (const \hyperlink{class_max_heap}{Max\+Heap} \&other\+Max\+Heap)=delete
\item 
\mbox{\Hypertarget{class_max_heap_af7ad902a96540ba9f5947ef0fc7bfa80}\label{class_max_heap_af7ad902a96540ba9f5947ef0fc7bfa80}} 
\hyperlink{class_max_heap_af7ad902a96540ba9f5947ef0fc7bfa80}{$\sim$\+Max\+Heap} ()
\begin{DoxyCompactList}\small\item\em Default Destructor. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_max_heap_afae77c1625c43b2319c0645e584b3dae}\label{class_max_heap_afae77c1625c43b2319c0645e584b3dae}} 
\hyperlink{class_max_heap}{Max\+Heap} \& {\bfseries operator=} (const \hyperlink{class_max_heap}{Max\+Heap} \&other\+Max\+Heap)=delete
\item 
void \hyperlink{class_max_heap_ab44116cd54d2caa1307df0d073e67514}{insert} (const T \&element)
\begin{DoxyCompactList}\small\item\em Insert an element into the \hyperlink{class_max_heap}{Max\+Heap}. \end{DoxyCompactList}\item 
bool \hyperlink{class_max_heap_a86b8d8285cf18a32544fe4777f9abbbb}{delete\+Element} (const T \&element)
\begin{DoxyCompactList}\small\item\em Deletes an element from \hyperlink{class_max_heap}{Max\+Heap}. \end{DoxyCompactList}\item 
bool \hyperlink{class_max_heap_afb84751d5d8f891260a4e30bdc2d2c38}{delete\+All} (const T \&element)
\begin{DoxyCompactList}\small\item\em Deletes all occurrences of an element from the \hyperlink{class_max_heap}{Max\+Heap}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_max_heap_a039088e9eb3b7a9f478b9c011b1183b1}\label{class_max_heap_a039088e9eb3b7a9f478b9c011b1183b1}} 
void \hyperlink{class_max_heap_a039088e9eb3b7a9f478b9c011b1183b1}{delete\+Max} ()
\begin{DoxyCompactList}\small\item\em Delete the largest element in the \hyperlink{class_max_heap}{Max\+Heap}. \end{DoxyCompactList}\item 
void \hyperlink{class_max_heap_a1c3366efa7a0b61ed484fa7266c37bf9}{replace\+Max} (const T \&element)
\begin{DoxyCompactList}\small\item\em Replace the largest element in the \hyperlink{class_max_heap}{Max\+Heap} with another element. \end{DoxyCompactList}\item 
bool \hyperlink{class_max_heap_a3ce799416b9373ec7a9f1fe2739812f1}{replace\+Element} (const T \&to\+Delete, const T \&to\+Insert)
\begin{DoxyCompactList}\small\item\em Replace an element in the \hyperlink{class_max_heap}{Max\+Heap} with another element. \end{DoxyCompactList}\item 
bool \hyperlink{class_max_heap_a9dd0757fb97c89db9a68604cf45e4ff0}{replace\+All} (const T \&to\+Delete, const T \&to\+Insert)
\begin{DoxyCompactList}\small\item\em Replace all occurrences of an element in the \hyperlink{class_max_heap}{Max\+Heap} with another element. \end{DoxyCompactList}\item 
bool \hyperlink{class_max_heap_af8f92dc7cd91a6c65825ee23150ba143}{exists} (const T \&element)
\begin{DoxyCompactList}\small\item\em Checks whether an element exists in the \hyperlink{class_max_heap}{Max\+Heap}. \end{DoxyCompactList}\item 
T \& \hyperlink{class_max_heap_a03c0806bbc4c9c166c065a7c280457c4}{find\+Max} () const
\begin{DoxyCompactList}\small\item\em Return, but do not delete the largest element in the \hyperlink{class_max_heap}{Max\+Heap}. \end{DoxyCompactList}\item 
T \& \hyperlink{class_max_heap_a31f3fe175dce628b83f79c31805feb59}{extract\+Max} ()
\begin{DoxyCompactList}\small\item\em Return and delete the largest element in the \hyperlink{class_max_heap}{Max\+Heap}. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{class_max_heap_a1894c47131530a277c2f778659520fa4}{size} () const
\begin{DoxyCompactList}\small\item\em Returns the number of elements in the \hyperlink{class_max_heap}{Max\+Heap}. \end{DoxyCompactList}\item 
bool \hyperlink{class_max_heap_aff04964e9ead102a8b98eaa00836351c}{is\+Empty} () const
\begin{DoxyCompactList}\small\item\em Checks whether the \hyperlink{class_max_heap}{Max\+Heap} has any elements. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_max_heap_ab08ef20423c039f010516091c2d361e6}\label{class_max_heap_ab08ef20423c039f010516091c2d361e6}} 
std\+::ostream \& \hyperlink{class_max_heap_ab08ef20423c039f010516091c2d361e6}{print} (std\+::ostream \&out) const
\begin{DoxyCompactList}\small\item\em To print the \hyperlink{class_max_heap}{Max\+Heap}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_max_heap_a06b1a2f848736257ad47b48c98cb0aa1}\label{class_max_heap_a06b1a2f848736257ad47b48c98cb0aa1}} 
void \hyperlink{class_max_heap_a06b1a2f848736257ad47b48c98cb0aa1}{resize\+Array} ()
\begin{DoxyCompactList}\small\item\em Doubles the capacity of the array data member. \end{DoxyCompactList}\item 
void \hyperlink{class_max_heap_a9799c77a0dccb11d45e22e2756659af1}{bubble\+Up} (size\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Brings a larger element up to the correct position. \end{DoxyCompactList}\item 
void \hyperlink{class_max_heap_a6edb154786d8720f218d539244f9efaa}{bubble\+Down} (size\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Brings a smaller element down to the correct position. \end{DoxyCompactList}\item 
bool \hyperlink{class_max_heap_a26d90c2f692856397fa8e4e222b8c549}{delete\+Element\+Helper} (const T \&element, size\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Recursive helper for delete\+Element. \end{DoxyCompactList}\item 
bool \hyperlink{class_max_heap_a26e23759a8c4a77c01b3b7d4f0eca424}{replace\+Element\+Helper} (size\+\_\+t index, const T \&to\+Delete, const T \&to\+Insert)
\begin{DoxyCompactList}\small\item\em Recursive helper for replace\+Element. \end{DoxyCompactList}\item 
bool \hyperlink{class_max_heap_a47d8b82e83d9877f8251d9b533fecea2}{exists\+Helper} (const T \&element, size\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Recursive helper for exists. \end{DoxyCompactList}\item 
void \hyperlink{class_max_heap_a06a4eaee6d86a0e332b38ed1f382c969}{swap\+Parent\+With\+Child} (size\+\_\+t parent\+Index, bool left)
\begin{DoxyCompactList}\small\item\em Helper function to swap a parent node with its child. \end{DoxyCompactList}\item 
std\+::ostream \& \hyperlink{class_max_heap_acb7f5834d10b183fd9e38992f563ba86}{print\+Helper} (size\+\_\+t index, std\+::ostream \&out, size\+\_\+t level) const
\begin{DoxyCompactList}\small\item\em Recursive Helper for string printing. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_max_heap_a790bbf28c9bbb52d6536b29e9104abf1}\label{class_max_heap_a790bbf28c9bbb52d6536b29e9104abf1}} 
T $\ast$$\ast$ \hyperlink{class_max_heap_a790bbf28c9bbb52d6536b29e9104abf1}{arr\+\_\+}
\begin{DoxyCompactList}\small\item\em Array of pointers storing the elements in the \hyperlink{class_max_heap}{Max\+Heap}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_max_heap_a0c0c7743a2aea092ec5b5fef184f8449}\label{class_max_heap_a0c0c7743a2aea092ec5b5fef184f8449}} 
size\+\_\+t \hyperlink{class_max_heap_a0c0c7743a2aea092ec5b5fef184f8449}{capacity\+\_\+}
\begin{DoxyCompactList}\small\item\em Capacity of the array. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_max_heap_ab3d7d763f6dd0fd197145f9c2b4704fa}\label{class_max_heap_ab3d7d763f6dd0fd197145f9c2b4704fa}} 
size\+\_\+t \hyperlink{class_max_heap_ab3d7d763f6dd0fd197145f9c2b4704fa}{size\+\_\+}
\begin{DoxyCompactList}\small\item\em Number of elements in Max\+Heaps. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_max_heap_a123615251bd8fcd2e79e95cd5496f82c}\label{class_max_heap_a123615251bd8fcd2e79e95cd5496f82c}} 
static const size\+\_\+t \hyperlink{class_max_heap_a123615251bd8fcd2e79e95cd5496f82c}{O\+R\+I\+G\+I\+N\+A\+L\+\_\+\+C\+A\+P\+A\+C\+I\+TY} = 4
\begin{DoxyCompactList}\small\item\em Starting size of array data member. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename T$>$\newline
class Max\+Heap$<$ T $>$}

Implementation of a max heap binary tree. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_max_heap_a699765b3f302e72791fe0de91c36aa39}\label{class_max_heap_a699765b3f302e72791fe0de91c36aa39}} 
\index{Max\+Heap@{Max\+Heap}!Max\+Heap@{Max\+Heap}}
\index{Max\+Heap@{Max\+Heap}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{Max\+Heap()}{MaxHeap()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::\hyperlink{class_max_heap}{Max\+Heap} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Default Constructor. 

Creates an empty \hyperlink{class_max_heap}{Max\+Heap} \mbox{\Hypertarget{class_max_heap_a059ca3f1547c9695df3b2ed6b78ba762}\label{class_max_heap_a059ca3f1547c9695df3b2ed6b78ba762}} 
\index{Max\+Heap@{Max\+Heap}!Max\+Heap@{Max\+Heap}}
\index{Max\+Heap@{Max\+Heap}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{Max\+Heap()}{MaxHeap()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::\hyperlink{class_max_heap}{Max\+Heap} (\begin{DoxyParamCaption}\item[{T}]{array\mbox{[}$\,$\mbox{]},  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Parameterized Constructor. 

Creates a \hyperlink{class_max_heap}{Max\+Heap} from elements of an array


\begin{DoxyParams}{Parameters}
{\em array} & A pointer to an array \\
\hline
{\em length} & The length of the array \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_max_heap_a6edb154786d8720f218d539244f9efaa}\label{class_max_heap_a6edb154786d8720f218d539244f9efaa}} 
\index{Max\+Heap@{Max\+Heap}!bubble\+Down@{bubble\+Down}}
\index{bubble\+Down@{bubble\+Down}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{bubble\+Down()}{bubbleDown()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::bubble\+Down (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Brings a smaller element down to the correct position. 


\begin{DoxyParams}{Parameters}
{\em index} & Index of element in array \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_max_heap_a9799c77a0dccb11d45e22e2756659af1}\label{class_max_heap_a9799c77a0dccb11d45e22e2756659af1}} 
\index{Max\+Heap@{Max\+Heap}!bubble\+Up@{bubble\+Up}}
\index{bubble\+Up@{bubble\+Up}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{bubble\+Up()}{bubbleUp()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::bubble\+Up (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Brings a larger element up to the correct position. 


\begin{DoxyParams}{Parameters}
{\em index} & Index of element in array \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_max_heap_afb84751d5d8f891260a4e30bdc2d2c38}\label{class_max_heap_afb84751d5d8f891260a4e30bdc2d2c38}} 
\index{Max\+Heap@{Max\+Heap}!delete\+All@{delete\+All}}
\index{delete\+All@{delete\+All}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{delete\+All()}{deleteAll()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::delete\+All (\begin{DoxyParamCaption}\item[{const T \&}]{element }\end{DoxyParamCaption})}



Deletes all occurrences of an element from the \hyperlink{class_max_heap}{Max\+Heap}. 


\begin{DoxyParams}{Parameters}
{\em element} & Object to delete \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if element is in \hyperlink{class_max_heap}{Max\+Heap} 
\end{DoxyReturn}
\mbox{\Hypertarget{class_max_heap_a86b8d8285cf18a32544fe4777f9abbbb}\label{class_max_heap_a86b8d8285cf18a32544fe4777f9abbbb}} 
\index{Max\+Heap@{Max\+Heap}!delete\+Element@{delete\+Element}}
\index{delete\+Element@{delete\+Element}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{delete\+Element()}{deleteElement()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::delete\+Element (\begin{DoxyParamCaption}\item[{const T \&}]{element }\end{DoxyParamCaption})}



Deletes an element from \hyperlink{class_max_heap}{Max\+Heap}. 


\begin{DoxyParams}{Parameters}
{\em element} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if element is in \hyperlink{class_max_heap}{Max\+Heap} 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
If \hyperlink{class_max_heap}{Max\+Heap} containes multiple occurrences of element, only one is deleted. 
\end{DoxyNote}
\mbox{\Hypertarget{class_max_heap_a26d90c2f692856397fa8e4e222b8c549}\label{class_max_heap_a26d90c2f692856397fa8e4e222b8c549}} 
\index{Max\+Heap@{Max\+Heap}!delete\+Element\+Helper@{delete\+Element\+Helper}}
\index{delete\+Element\+Helper@{delete\+Element\+Helper}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{delete\+Element\+Helper()}{deleteElementHelper()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::delete\+Element\+Helper (\begin{DoxyParamCaption}\item[{const T \&}]{element,  }\item[{size\+\_\+t}]{index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Recursive helper for delete\+Element. 


\begin{DoxyParams}{Parameters}
{\em element} & Element to delete \\
\hline
{\em index} & Index of element in array \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_max_heap_af8f92dc7cd91a6c65825ee23150ba143}\label{class_max_heap_af8f92dc7cd91a6c65825ee23150ba143}} 
\index{Max\+Heap@{Max\+Heap}!exists@{exists}}
\index{exists@{exists}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{exists()}{exists()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::exists (\begin{DoxyParamCaption}\item[{const T \&}]{element }\end{DoxyParamCaption})}



Checks whether an element exists in the \hyperlink{class_max_heap}{Max\+Heap}. 


\begin{DoxyParams}{Parameters}
{\em element} & Element to search for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if element is in the \hyperlink{class_max_heap}{Max\+Heap} 
\end{DoxyReturn}
\mbox{\Hypertarget{class_max_heap_a47d8b82e83d9877f8251d9b533fecea2}\label{class_max_heap_a47d8b82e83d9877f8251d9b533fecea2}} 
\index{Max\+Heap@{Max\+Heap}!exists\+Helper@{exists\+Helper}}
\index{exists\+Helper@{exists\+Helper}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{exists\+Helper()}{existsHelper()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::exists\+Helper (\begin{DoxyParamCaption}\item[{const T \&}]{element,  }\item[{size\+\_\+t}]{index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Recursive helper for exists. 


\begin{DoxyParams}{Parameters}
{\em element} & Element to search for \\
\hline
{\em index} & Index of element in array \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if element is in the \hyperlink{class_max_heap}{Max\+Heap} 
\end{DoxyReturn}
\mbox{\Hypertarget{class_max_heap_a31f3fe175dce628b83f79c31805feb59}\label{class_max_heap_a31f3fe175dce628b83f79c31805feb59}} 
\index{Max\+Heap@{Max\+Heap}!extract\+Max@{extract\+Max}}
\index{extract\+Max@{extract\+Max}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{extract\+Max()}{extractMax()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T \& \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::extract\+Max (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Return and delete the largest element in the \hyperlink{class_max_heap}{Max\+Heap}. 

\begin{DoxyReturn}{Returns}
The largest element in the Heap 
\end{DoxyReturn}
\mbox{\Hypertarget{class_max_heap_a03c0806bbc4c9c166c065a7c280457c4}\label{class_max_heap_a03c0806bbc4c9c166c065a7c280457c4}} 
\index{Max\+Heap@{Max\+Heap}!find\+Max@{find\+Max}}
\index{find\+Max@{find\+Max}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{find\+Max()}{findMax()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T \& \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::find\+Max (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Return, but do not delete the largest element in the \hyperlink{class_max_heap}{Max\+Heap}. 

\begin{DoxyReturn}{Returns}
The largest element in the Heap 
\end{DoxyReturn}
\mbox{\Hypertarget{class_max_heap_ab44116cd54d2caa1307df0d073e67514}\label{class_max_heap_ab44116cd54d2caa1307df0d073e67514}} 
\index{Max\+Heap@{Max\+Heap}!insert@{insert}}
\index{insert@{insert}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{insert()}{insert()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::insert (\begin{DoxyParamCaption}\item[{const T \&}]{element }\end{DoxyParamCaption})}



Insert an element into the \hyperlink{class_max_heap}{Max\+Heap}. 


\begin{DoxyParams}{Parameters}
{\em element} & to insert \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_max_heap_aff04964e9ead102a8b98eaa00836351c}\label{class_max_heap_aff04964e9ead102a8b98eaa00836351c}} 
\index{Max\+Heap@{Max\+Heap}!is\+Empty@{is\+Empty}}
\index{is\+Empty@{is\+Empty}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{is\+Empty()}{isEmpty()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::is\+Empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Checks whether the \hyperlink{class_max_heap}{Max\+Heap} has any elements. 

\begin{DoxyReturn}{Returns}
true if the \hyperlink{class_max_heap}{Max\+Heap} is empty 
\end{DoxyReturn}
\mbox{\Hypertarget{class_max_heap_acb7f5834d10b183fd9e38992f563ba86}\label{class_max_heap_acb7f5834d10b183fd9e38992f563ba86}} 
\index{Max\+Heap@{Max\+Heap}!print\+Helper@{print\+Helper}}
\index{print\+Helper@{print\+Helper}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{print\+Helper()}{printHelper()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
ostream \& \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::print\+Helper (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{index,  }\item[{std\+::ostream \&}]{out,  }\item[{size\+\_\+t}]{level }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [private]}}



Recursive Helper for string printing. 


\begin{DoxyParams}{Parameters}
{\em index} & Index of parent in array \\
\hline
{\em out} & ostream to send it to \\
\hline
{\em level} & The depth of the current Node \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_max_heap_a9dd0757fb97c89db9a68604cf45e4ff0}\label{class_max_heap_a9dd0757fb97c89db9a68604cf45e4ff0}} 
\index{Max\+Heap@{Max\+Heap}!replace\+All@{replace\+All}}
\index{replace\+All@{replace\+All}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{replace\+All()}{replaceAll()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::replace\+All (\begin{DoxyParamCaption}\item[{const T \&}]{to\+Delete,  }\item[{const T \&}]{to\+Insert }\end{DoxyParamCaption})}



Replace all occurrences of an element in the \hyperlink{class_max_heap}{Max\+Heap} with another element. 

More efficient than deleting and then inserting because it only has to rebalance once for each occurrence of to\+Delete


\begin{DoxyParams}{Parameters}
{\em to\+Delete} & Object to delete \\
\hline
{\em to\+Insert} & Object to insert \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_max_heap_a3ce799416b9373ec7a9f1fe2739812f1}\label{class_max_heap_a3ce799416b9373ec7a9f1fe2739812f1}} 
\index{Max\+Heap@{Max\+Heap}!replace\+Element@{replace\+Element}}
\index{replace\+Element@{replace\+Element}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{replace\+Element()}{replaceElement()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::replace\+Element (\begin{DoxyParamCaption}\item[{const T \&}]{to\+Delete,  }\item[{const T \&}]{to\+Insert }\end{DoxyParamCaption})}



Replace an element in the \hyperlink{class_max_heap}{Max\+Heap} with another element. 

More efficient than deleting and then inserting because it only has to rebalance once


\begin{DoxyParams}{Parameters}
{\em to\+Delete} & Object to delete \\
\hline
{\em to\+Insert} & Object to insert \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_max_heap_a26e23759a8c4a77c01b3b7d4f0eca424}\label{class_max_heap_a26e23759a8c4a77c01b3b7d4f0eca424}} 
\index{Max\+Heap@{Max\+Heap}!replace\+Element\+Helper@{replace\+Element\+Helper}}
\index{replace\+Element\+Helper@{replace\+Element\+Helper}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{replace\+Element\+Helper()}{replaceElementHelper()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::replace\+Element\+Helper (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{index,  }\item[{const T \&}]{to\+Delete,  }\item[{const T \&}]{to\+Insert }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Recursive helper for replace\+Element. 


\begin{DoxyParams}{Parameters}
{\em index} & Index of element in array \\
\hline
{\em to\+Delete} & Element to delete \\
\hline
{\em to\+Insert} & Element to insert \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if element is in the \hyperlink{class_max_heap}{Max\+Heap} 
\end{DoxyReturn}
\mbox{\Hypertarget{class_max_heap_a1c3366efa7a0b61ed484fa7266c37bf9}\label{class_max_heap_a1c3366efa7a0b61ed484fa7266c37bf9}} 
\index{Max\+Heap@{Max\+Heap}!replace\+Max@{replace\+Max}}
\index{replace\+Max@{replace\+Max}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{replace\+Max()}{replaceMax()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::replace\+Max (\begin{DoxyParamCaption}\item[{const T \&}]{element }\end{DoxyParamCaption})}



Replace the largest element in the \hyperlink{class_max_heap}{Max\+Heap} with another element. 

More efficient than deleting and then inserting because it only has to rebalance once


\begin{DoxyParams}{Parameters}
{\em element} & Object to insert \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_max_heap_a1894c47131530a277c2f778659520fa4}\label{class_max_heap_a1894c47131530a277c2f778659520fa4}} 
\index{Max\+Heap@{Max\+Heap}!size@{size}}
\index{size@{size}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
size\+\_\+t \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Returns the number of elements in the \hyperlink{class_max_heap}{Max\+Heap}. 

\begin{DoxyReturn}{Returns}
The number of elements in the \hyperlink{class_max_heap}{Max\+Heap} 
\end{DoxyReturn}
\mbox{\Hypertarget{class_max_heap_a06a4eaee6d86a0e332b38ed1f382c969}\label{class_max_heap_a06a4eaee6d86a0e332b38ed1f382c969}} 
\index{Max\+Heap@{Max\+Heap}!swap\+Parent\+With\+Child@{swap\+Parent\+With\+Child}}
\index{swap\+Parent\+With\+Child@{swap\+Parent\+With\+Child}!Max\+Heap@{Max\+Heap}}
\subsubsection{\texorpdfstring{swap\+Parent\+With\+Child()}{swapParentWithChild()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void \hyperlink{class_max_heap}{Max\+Heap}$<$ T $>$\+::swap\+Parent\+With\+Child (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{parent\+Index,  }\item[{bool}]{left }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Helper function to swap a parent node with its child. 


\begin{DoxyParams}{Parameters}
{\em parent\+Index} & Index of parent in array \\
\hline
{\em left} & true for swap with left child, false for swap with right child \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{maxheap_8hpp}{maxheap.\+hpp}\item 
maxheap-\/private.\+hpp\end{DoxyCompactItemize}
